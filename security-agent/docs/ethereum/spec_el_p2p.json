{
  "system_architecture": {
    "core_modules": [
      {
        "name": "ピア発見サービス（Discovery v4/v5）",
        "description": "イーサリアムのピア発見プロトコル（主にDiscovery v4）を実装するモジュールです。Kademlia方式のDHTテーブルでピア情報を管理し、ブートノード経由でネットワーク上のノードを探索します。ノードレコード（ENR）を用いて各ピアのアドレス・公開鍵・フォークID等の情報を交換し、発見したノード群をキューに入れます。DiscoveryサービスはUDPで動作し、Ethereum Node Recordを介して自身の情報も公開します。またRethではdiscovery v4をデフォルト使用しつつ、必要に応じてDiscovery v5やDNSディスカバリによるノード探索にも対応しています。",
        "responsibility": "ノード起動時にピア発見を開始し、既知のブートノードに問い合わせて新たなピア候補を取得します。発見したノードについて、フォークID（EIP-868）やチェーンIDを確認し、適切なチェーンのピアのみを接続候補として保持します。継続的にネットワーク探索を行い、ピアリストを更新し続け、ネットワークマネージャに接続可能な候補ピアを提供します。"
      },
      {
        "name": "ネットワークマネージャとセッション管理",
        "description": "ネットワークマネージャ（NetworkManager）はP2Pネットワーク全体を統括する中核モジュールで、内部で**Swarm**と呼ばれるタスク群を管理します。新規ピアとの接続確立（TCPソケット受け入れ・発信）からRLPxハンドシェイク（ECIESによる鍵交換・セッション暗号化）まで処理し、各ピアとのセッションを確立します。Swarmは発生したイベント（接続確立、切断、受信メッセージ等）をNetworkManagerへ通知し、NetworkManagerはそれを処理してピア状態を追跡・更新します。例えばNetworkManager内部のネットワーク状態（NetworkState）は現在の接続ピア一覧を保持し、新規発見ピアをアウトバウンド接続すべき候補としてキュー管理します。また**セッションマネージャ**は全既存セッションを維持・監視し、ハンドシェイク完了後の各ピアとのメッセージ送受信（RLPx暗号化通信）のエンコード/デコードも担当します:contentReference[oaicite:2]{index=2}。",
        "responsibility": "ネットワーク全体のピア接続ライフサイクルを管理します。具体的には、所定の最大ピア数に達するまでアウトバウンド接続を開始し、不要になった接続を適宜切断します。着信したインバウンド接続も受け入れ、RLPxハンドシェイクを完了したピアのみを有効な接続として登録します。さらに内部では各サブプロトコル（ethやsnap）のリクエスト処理タスクとも連携し、他モジュール（例: 同期処理やトランザクションプール）からのデータ要求をピアネットワーク経由で送信するためのインターフェース（FetchClient）も提供します。"
      },
      {
        "name": "Ethereum ETHプロトコルハンドラ",
        "description": "イーサリアムのメインデータ交換プロトコルである`eth`プロトコル（バージョン66以降）を実装するモジュールです。ブロックやトランザクションのゴシップ（新規ブロック通知やプール未処理トランザクション通知）および、ブロック同期のためのリクエスト/レスポンス（ヘッダ・ブロック本体・レシート要求など）を処理します。eth/66ではリクエストにIDが付与され、複数の要求を同時並行で処理可能になっています:contentReference[oaicite:3]{index=3}。Rethのethプロトコル実装では、EIP-2464に従い新規トランザクションはハッシュのみをブロードキャストし（`NewPooledTransactionHashes`）、必要に応じてピアが取引本体を要求することで帯域を節約しています:contentReference[oaicite:4]{index=4}。また、新規ブロックについては一部ピアに対して`NewBlock`メッセージでブロック全体を送り、高速に伝播させつつ、大多数のピアへは`NewBlockHashes`でハッシュ通知のみ行うといった効率的なゴシップ戦略にも対応しています。",
        "responsibility": "ピアとの間でEthereumブロックチェーンデータを同期します。起動時にはステータス（Status）メッセージを交換してチェーンの一致（ネットワークIDやフォーク情報）を確認し、その後は新規ブロックの受信・送信、トランザクションの共有、過去ブロックの要求（例: `GetBlockHeaders`等）と応答、および必要な状態データの取得要求など、各種のethプロトコルメッセージを送受信します。これにより自ノードのブロックチェーンを最新状態に保ち、他ノードからの同期要求にも応答してネットワーク全体のデータ維持に貢献します。"
      },
      {
        "name": "ステート同期（Snap）プロトコル",
        "description": "Ethereumのスナップショット同期プロトコル（`snap`）を扱うモジュールです。スナップシンク（Snap Sync）はトライノードを一つ一つダウンロードする代わりに、状態データ（アカウントやストレージ）の連続したチャンクをピアから取得できる同期方式です:contentReference[oaicite:5]{index=5}。Rethでは`snap/1`サブプロトコルをサポートしており、ethプロトコルとは独立に並行して動作します:contentReference[oaicite:6]{index=6}。このモジュールはスナップショット同期用の要求と応答（例えば一定範囲のアカウント一覧要求）をエンコード/デコードし、ピアと状態データを効率的に交換します。",
        "responsibility": "初期同期時にネットワークから状態データを高速に取得する役割を担います。例えばチェーンのヘッダとブロック本体同期完了後、不足している最新状態をSnapプロトコルでピアに要求し、大量のアカウントやストレージ項目をチャンク単位でダウンロードします。また、自ノードが十分に同期済みの場合、他のピアからのSnap要求に応答して、指定された範囲の状態データを提供します。ただし大量の状態データ要求が乱用されないように提供側に制限を設け、ノード資源を保護します。"
      }
    ],
    "external_dependencies": [
      {
        "name": "ブートノード",
        "description": "ネットワーク参加時に最初に連絡を取る既知のノードリストです。Rethには主要ネットワーク（メインネットや各テストネット）のブートノードのENRアドレスが組み込みで用意されており、起動時にこれらに接続することでピア発見をブートストラップします:contentReference[oaicite:7]{index=7}。"
      },
      {
        "name": "DNSディスカバリ",
        "description": "オプションのピア発見手段として、DNSシードを利用したノード発見に対応しています。Ethereum財団が提供するDNSサービスからネットワーク上のノードENR一覧を取得し、追加のピア候補として使用できます。DNSディスカバリはデフォルトでは無効ですが、ユーザが設定することで有効化できます。"
      }
    ]
  },
  "user_flows": [
    {
      "flow_name": "ピア発見と接続ハンドシェイク",
      "description": "Rethノードが起動し、ピア発見を通じて新たなピアを見つけ、暗号化されたP2P接続を確立するまでの流れです。Discoveryプロトコルでノード情報を収集した後、RLPxハンドシェイクとETHプロトコル・ハンドシェイクを行い、Ethereumデータのやり取りが可能なピアとして認識します。",
      "steps": [
        "ノード起動時にブートノードのENRリストを読み込み、Discovery v4サービスを開始します。RethはUDP経由でブートノードにpingを送り、応答で得られたノード情報を元にネットワーク上の他ノードを探索します。",
        "発見した各ノードについて、自ノードと異なるチェーンでないかを確認します。具体的には、発見パケット内のFork ID（フォーク識別子）やジェネシスハッシュを参照し、自チェーンと互換性のないノードとは接続しません:contentReference[oaicite:8]{index=8}。これにより異なるネットワーク（例えば他チェーンや古いフォーク）への誤接続を防ぎます。",
        "NetworkManagerは発見されたピア候補に対しアウトバウンドのTCP接続を順次試みます。指定ポート（通常30303番）への接続が開通すると、まずRLPxプロトコルでハンドシェイクを行います。これはECDH鍵交換により共有秘密鍵を生成し、お互いのノードID（secp256k1公開鍵）を確認するプロセスで、成功すると以降の通信が暗号化されます。",
        "RLPxハンドシェイク完了後、DevP2Pのプロトコルネゴシエーションが行われます。両ノードは自分のサポートするサブプロトコル（例: eth/66, snap/1 等）の一覧を交換し、共通のサブプロトコルがあるか確認します。共通にethプロトコルが利用可能であれば、Ethereum `Status`メッセージの交換に進みます。",
        "Rethは新規ピアとの間で`Status`メッセージを送信し、自身のチェーン情報（ネットワークID、最新ブロック番号、フォークIDなど）を知らせ、相手からも同様の情報を受け取ります。これにより両者が同一のチェーン（チェーンIDとフォークポイントが一致）で動作していることを確認します:contentReference[oaicite:9]{index=9}。このステップが正常に完了すると、そのピアはEthereumデータ同期が可能な正式な接続ピアとして登録されます。",
        "確立されたピア接続は、NetworkManagerの管理下でピアリストに追加されます。以降、このピアとの間でブロックやトランザクションのP2Pメッセージ交換が可能となります。ノードはさらに追加のピアを発見・接続して、所定のピア数に達するまでこのプロセスを繰り返します（既に十分なピアがいる場合は新規接続を制限します）。"
      ],
      "security_checkpoints": [
        "発見したノードのチェーン識別情報を検証（ジェネシスハッシュやフォークIDが異なる場合は接続しない）。これにより異なるチェーンへの誤接続を防止します。",
        "RLPxハンドシェイク時に公開鍵署名検証とECDH鍵交換を行い、ピアの正当性を確認するとともに通信内容を暗号化して盗聴や改ざんを防ぎます。",
        "ピアごとのサブプロトコル対応状況をチェックし、サポート外のプロトコルでは通信しません。これにより不正なメッセージや想定外のプロトコルでの攻撃を受けにくくします。",
        "接続ピア数の上限や接続試行頻度を制限しています。一度に過剰なピアと接続しようとしないことでリソース枯渇を防ぎ、また短時間に何度も失敗接続を繰り返す相手は一定時間ブロックするなど、接続面でのDoS耐性を持たせています。",
        "ハンドシェイクやステータス確認に失敗したピア、応答のないピアは速やかに切断・除外します。無効なピアと長時間接続を保持しないことで、リソースの無駄遣いや悪意あるノードからの攻撃表面を減らします。"
      ]
    },
    {
      "flow_name": "ブロックの伝播とチェーン同期",
      "description": "ネットワーク上で新しいブロックが生成または検出された際に、それがピア間でどのように広まり、自ノードのブロックチェーンに取り込まれるかの流れです。PoS移行後はExecutionレイヤーのRethがブロック実行を検証し、Consensusレイヤー（ビーコンノード）がブロックの最終性を決定するという連携になります。このフローではブロックのゴシップから検証・チェーンへの適用までを扱います。",
      "steps": [
        "ネットワーク上で新たなブロックが生成されると、接続ピアから`NewBlockHashes`メッセージでそのブロックのハッシュ（とブロック番号）が通知されます。場合によっては、信頼度の高い一部ピアからはブロック全体を含む`NewBlock`メッセージが直接送られてくることもあります（ピアが自分で採掘/提案した場合や、親密なピアからの優先配信）:contentReference[oaicite:10]{index=10}。",
        "Rethは受信したブロック通知について、自分がそのブロックを未保持であれば、対応する完全なブロックデータを取得するため要求を送信します。例えば`NewBlockHashes`のみ受け取った場合、まず`GetBlockHeaders`メッセージで当該ハッシュのブロックヘッダを要求し、続けて`GetBlockBodies`でトランザクション一覧（ブロック本体）を要求します。必要に応じて複数のピアに要求を分散し、欠損データを効率よく取得します。",
        "ブロック本体を入手すると、まずヘッダ情報の検証を行います（親ブロックのハッシュが現在のチェーン先端と一致するか、タイムスタンプが過去のブロックより後で現在時刻より極端に未来でないか、など）。PoSチェーンの場合、ヘッダ内の提案者署名やスロット等の検証はビーコンノードが担当するため、ExecutionクライアントであるReth側では主に形式やPoW残留項目のチェック（適切に難易度0になっているか等）を行います。",
        "続いてRethはブロック内の全トランザクションを順番に実行し、イーサリアムの状態を更新します。EVMを用いて各トランザクションを適用し終えたら、新しいステートルートを計算し、それがブロックヘッダに記載されたポストステートルートと一致することを確認します。あわせて、トランザクション実行結果のレシートルートや、消費したガス量がブロックのガス上限以内であることも検証します。全トランザクション実行が成功しブロック全体が有効と判断されれば、次の段階に進みます。",
        "ブロックが自ノードで有効と検証されると、チェーンへの取り込みを行います。新ブロックの親が現在の最新ブロックであれば、そのブロックはチェーンの先端に延伸する形で追加され、Rethの持つチェーンヘッドが更新されます。一方、別のフォークのブロックだった場合、一時的にフォーク情報として保存します。その上で当該フォークが現在のメインチェーンを追い越すだけの累積難易度（またはPoS下ではより新しいチェックポイントや重み）を持った場合には、チェーンのリオーグ（再編成）を行い、新ブロックの属する枝を正規のチェーンとして昇格します。",
        "Rethはブロックを受理してチェーンに追加した後、自身が接続する他のピアへ向けてそのブロックをゴシップします。帯域効率のため、一部のピアには`NewBlock`メッセージでブロック全体を送信し、多数の残りのピアには`NewBlockHashes`でブロックハッシュのみを通知するというハイブリッドな伝播を行います:contentReference[oaicite:11]{index=11}。これによりブロックはネットワーク全体に効率よく拡散されます。",
        "最後にブロックの挿入完了に伴い、Consensus層（ビーコンノード）にはEngine API（例えば`engine_newPayload`）を通じて当該ブロックが実行成功した旨を報告します。ビーコンノードは必要に応じてフォークチョイスの更新（`engine_forkchoiceUpdated`）を行い、EL/CL間で最新ヘッドに関する見解を同期させます。またReth内部ではExecution Extension（ExEx）にブロック適用イベントが通知され、オンチェーントリガに応じた独自処理（インデックス作成等）が走ります。"
      ],
      "security_checkpoints": [
        "ブロックヘッダの妥当性検証（親ハッシュの整合性、タイムスタンプの順序、PoW→PoS移行後の難易度値検証など）を実施し、不正なヘッダのブロックは棄却します。",
        "（PoS時）ブロック提案者の署名検証やスロットチェックは外部のビーコンノードで行われ、Executionクライアント側でもエンジンAPIを介して無効ブロック受け入れを拒否します。PoW時代であれば、プロトコル規定のPoW難易度計算とnonce値の検証を行い、不正なブロックを拒絶します。",
        "EVM実行結果に基づくステートルートおよびレシートルートの照合を行い、ヘッダのコミットと一致しない場合はブロック全体を無効とします。これによりトランザクション改ざんや不整合を検知します。",
        "ガス消費やブロックサイズなど、コンセンサスルールに違反していないか確認します（例: ガス上限超過トランザクションが含まれていないか、無効なEVM操作が行われていないか）。違反があればブロックを拒否します。",
        "チェーンの再編成（リオーグ）が必要な場合でも、直近のfinalizedブロック（最終化済みブロック）より古い部分は巻き戻さないようにします。Rethは外部コンセンサス層との連携により、ファイナライズされたブロックより深い巻き戻しは許容しません。これにより攻撃者が最終化を覆す深いフォークを作ることを防ぎます。"
      ]
    }
  ],
  "security_features": [
    {
      "feature": "DoSガードとリソース制限",
      "description": "悪意あるピアによるサービス拒否攻撃への対策として、Rethは各種リソース制限を設けています。例えば、ネットワークメッセージのキューに上限を設定し、一つのピアから過剰な要求があってもメモリを無制限に消費しないようにしています:contentReference[oaicite:12]{index=12}。また、ピアごとのメッセージ処理時間や同時処理数にも制限をかけ、重たい計算を伴うリクエスト（例: 大量データ取得要求など）が他の処理をブロックしないように調整しています。一定以上にプロトコルに違反するデータを送ってくるピアは即座に切断し、必要に応じて接続禁止リストに登録（BAN）することでノードの健全性を保ちます。"
    },
    {
      "feature": "Snap同期のアクセス制御",
      "description": "スナップショット同期機能に対する乱用を防ぐための制限があります。Rethは他ピアからの巨大な状態データ要求に対して、一度に応答するデータ量や頻度を制限したり、信用度の低いピアにはスナップ同期データを提供しない設定を適用できます。これにより悪意あるノードがスナップ同期プロトコルを利用して過剰なデータを引き出しDoSを仕掛けることを防ぎます。またSnapでは各チャンク取得時に都度Merkle証明検証を行うため、不正なジャンクデータを送りつける攻撃もほぼ効果がありません:contentReference[oaicite:13]{index=13}。"
    },
    {
      "feature": "リオーグ（チェーン再編）保護",
      "description": "チェーンのフォーク発生時にそれを安全に処理する仕組みです。Rethは複数のフォークを同時に追跡しつつ、最終性がついたブロックより深い箇所の巻き戻しは拒否することで、深いリオーグ攻撃からチェーンを保護します。万一リオーグが発生した場合にも、Execution Extensionなどノード内の拡張機能へ`ChainReverted`イベントを発行し、それまでに行ったオフチェーン処理を取り消せるようにしています。これによりノード内外で矛盾する状態が生じることを防ぎます。"
    },
    {
      "feature": "ピアのレピュテーションと排除",
      "description": "各ピアの振る舞いに応じてスコアを与え、接続の維持可否を判断する仕組みです。メッセージ応答が極端に遅いピア、不正なデータを送りつけてくるピア、プロトコル違反が見られるピアにはスコアペナルティを科し、一定値を下回った場合に切断・BANします:contentReference[oaicite:14]{index=14}。これによりネットワークは高品質なピアとの接続を優先的に維持し、悪質なピアによる影響を低減します。ピアスコアリングとBANはネットワーク全体の健全性と安定性を維持する重要なセキュリティ機構です。"
    },
    {
      "feature": "トランザクションプールのスパム対策",
      "description": "RethのTxPool（トランザクションプール）は低手数料トランザクションのスパム投入を防ぐため、各種のルールを設けています。例えばEIP-1559下では最低でも現在のベースフィー以上のGas料金がないとプールに追加されません。また既にプールにある未承認トランザクションと同じnonceの新規トランザクションを投入する場合、元のGas価格より少なくとも10%以上上乗せした価格でないと受け付けません:contentReference[oaicite:15]{index=15}（微増による無効な置き換えを拒否）。さらに一つの送信元アドレスが大容量のプールを独占しないよう、未処理トランザクション数やnonceの先行きすぎ（ギャップ）にも上限を設けています。これらによりプールを利用したDoS攻撃やネットワーク上の不要トランザクション氾濫を抑制しています。"
    }
  ],
  "protocol_specifications": {
    "p2p_protocol": "DevP2P（RLPx）プロトコルを使用したピアツーピア通信。各ノードはECIES鍵交換に基づく暗号化セッションを確立し、静的なsecp256k1鍵によるPeer IDで識別されます。単一のRLPxセッション上で複数のサブプロトコル（eth、snap等）のメッセージを多重化して送受信します。DevP2Pプロトコルのバージョン5に準拠し、ピア同士のメッセージは全てRLPエンコードされたフレームとして暗号化伝送されます。",
    "discovery_protocol": "Discovery v4（UDPベース）を主に使用します。Kademlia型DHTによるノード探索でポート30303 UDP上で稼働し、ノード情報はENR（Ethereum Node Record）形式で交換されます:contentReference[oaicite:16]{index=16}。RethはDiscovery v5にもオプション対応しており、また一部ネットワークではDNSによるノード一覧取得もサポートします。DiscoveryプロトコルではノードIDにsecp256k1公開鍵を用いた「v4」スキームが使われ、ピア間でPing/Pongを交換して相互の外部アドレスを確認しあう機能も備えます。",
    "engine_api": "Engine JSON-RPC API v1をサポート（authポートで稼働）。これはExecutionクライアント（Reth）と外部Consensusクライアント（ビーコンノード）の通信インターフェースで、`engine_newPayload`や`engine_forkchoiceUpdated`等のメソッドを提供します（JWT認証により外部からの無権限アクセスを防止）。※ネットワークP2Pプロトコルとは別のローカル通信。PoW時代のRPC（eth_submitWork等）はPoS移行に伴い非推奨。",
    "execution_extensions": "Execution Extensions（ExEx）はReth独自の内部拡張フレームワークで、P2Pプロトコルとは直接関与しません。ブロック実行結果をフックしてカスタム処理を走らせるための仕組みで、gRPC等で外部出力することも可能ですが、基本的にはノード内での非同期処理として実装されます。",
    "data_serialization": "P2PメッセージはRLP（Recursive Length Prefix）形式でシリアライズされ、効率的なバイナリ伝送が行われます。ノード発見用のENRもRLPでエンコードされたレコードをBase64表現したものを使用します。Ethereum Beacon Chain関連データはSSZ形式ですが、これはRethではビーコンノード側で処理されます（ExecutionクライアントのP2PはRLP中心）。Reth内部実装では必要に応じCap’n ProtoやProtobufを活用していますが、ネットワーク越しの通信は既存プロトコル仕様に従ったフォーマットです。",
    "implementation_language": "Rustで実装されています（高パフォーマンスとメモリ安全性の両立のため）。例えばGo言語で書かれたgethに対し、RethはRust 1.78+のエコシステムを活かして非同期処理を実装しています。Tokioランタイム上で膨大なP2Pイベントを効率よく捌く設計となっており、低レベルネットワーク処理からEVM実行までシステムプログラミング言語ならではの最適化が図られています。",
    "key_libraries": "ネットワーク周りでは自前実装の`reth_discv4`クレートや`reth_network`モジュールを使用し、libp2pなど外部P2Pフレームワークには依存していません。暗号処理にはRust製のsecp256k1ライブラリを用い、RLPエンコード/デコード処理もRust向けに最適化されています。また非同期処理全般はTokioを基盤とし、マルチスレッド環境で多数のピアとの通信を並列に処理できるよう設計されています。",
    "build_and_deployment": "Cargo経由でビルド・インストール可能なRustクレート/バイナリとして提供されています。Linux (Ubuntu 22.04等)を主対象にクロスプラットフォーム対応しており、公式Dockerイメージも用意されています。CI（継続的インテグレーション）により各プルリクエストでビルドとテストが自動検証されており、リリースごとに再現性のあるビルドが保証されています。"
  },
  "external_dependencies": {
    "beacon_node": {
      "required": true,
      "description": "PoS移行後のEthereumネットワークでは、外部のコンセンサス層クライアント（ビーコンノード）が必要不可欠です。Reth単体ではブロック提案者選出や最終化判断ができないため、Engine APIを介してBeaconノードから新規ブロック提案やフォークチョイスの指示を受け取り、ブロック実行結果を報告します。したがってメインネット運用時には必ず対応するビーコンノード（例: Lighthouse, Prysm等）とJWT秘密鍵の設定が必要です。"
    },
    "bootnodes_list": {
      "required": true,
      "description": "ネットワーク参加時に利用される既知ノードのリストです。Rethにはデフォルトでイーサリアムメインネットおよび主要テストネットのブートノードENRがハードコーディングされており、初期発見に使用されます。ユーザがカスタムネットを運用する場合には、このブートノードリストを適切に設定する必要があります。"
    },
    "oracle_services": {
      "required": false,
      "description": "チェーン外オラクル等の外部サービスは、コア機能上は必要ありません。Rethはプロトコル上のデータのみで動作し、価格フィード等のオラクルに依存しない設計です。"
    },
    "external_signer": {
      "required": false,
      "description": "トランザクションの署名用に外部署名サービスを利用することも可能ですが、必須ではありません。Reth自体にキーストア機能があり秘密鍵管理・署名が可能です。必要に応じてJSON-RPC経由でclef等の外部署名デーモンやハードウェアウォレットと連携することもできますが、これらはオプションです。"
    },
    "mev_boost": {
      "required": false,
      "description": "MEV-Boostとの連携は必須ではありません。バリデータ運用時にMEV-Boostを使用する場合でも、それはコンセンサスクライアント側（ビーコンノード）でハンドルされ、Reth（Executionクライアント）はEngine API経由で提供されるペイロードを実行するだけです。Reth自体がMEVブーストリレーと直接通信することはなく、MEV利用は外部コンポーネントを通して行われます。"
    },
    "light_client_fallback": {
      "available": false,
      "description": "Rethにはライトクライアントモードやそのフェイルセーフ機能は組み込まれていません。一度ビーコンノードとの接続が失われたり停止すると、自律的にチェーンの先端を追跡し続けることはできません。ポストマージ後のExecutionクライアントは必ず外部コンセンサス層に依存するため、単独でのライトクライアント的動作は想定されていません。"
    }
  },
  "design_changes": [
    {
      "change_type": "マージ（PoW→PoS移行）",
      "rationale": "EthereumはThe Mergeアップグレードにより、従来のPoWによるブロック生成を廃止してPoSベースのビーコンチェーンに統合しました。これによりエネルギー効率の改善と、コンセンサス層と実行層の役割分離が図られました。ExecutionクライアントであるRethはブロック実行に専念し、ブロック提案・検証の決定は外部のコンセンサスノードが行う設計に移行しました。",
      "impact_on_specification": "この変更に伴い、Rethには新たにEngine API（コンセンサス層とのJSON-RPCブリッジ）が実装されました。マイニングロジックが不要となったため、ethプロトコルの一部フィールド（例: 総難易度情報など）は使用されなくなり、代替としてフォークチョイスや最終化情報の扱いが追加されています。またPoSでは外部から提案ブロックが直接与えられるため、Reth内部のブロック生成（eth_getWork等）は無効化され、常にビーコンノードからの`engine_newPayload`コマンドでブロック実行を開始します。さらに最終性を踏まえたフォーク処理が仕様に加わり、Rethはビーコンノードから通知されるfinalizedブロックより古い分岐は受け付けないことで、一度確定したチェーンを覆すような深いリオーグを拒絶するよう仕様が変更されました。"
    },
    {
      "change_type": "EIP-4844（Proto-Danksharding、Blobトランザクション）",
      "rationale": "Ethereumのスケーラビリティ向上を目的としたCancun/Deneb（通称Dencun）アップグレードの一部で、ブロブ付きトランザクションと呼ばれる大型データペイロードを一時的にチェーン上に載せる仕組みを導入する提案です。これによりL2ロールアップがブロブに大量のオフチェーンデータを格納して安価にL1確保できるようになり、Calldata使用に比べ手数料削減が期待されます。",
      "impact_on_specification": "Rethは新トランザクションタイプ（タイプ3：Blob付きトランザクション）に対応しました。従来のトランザクションと異なり追加のフィールド（blobのKZGコミットメントリスト等）を扱う必要があるため、トランザクションプールやEVM実行ロジックを拡張しています。実行クライアントであるRethはブロブ本体データを直接扱わず、ブロブデータはコンセンサス層のBlobサイドカー経由でネットワーク上を伝播します:contentReference[oaicite:17]{index=17}。Reth側では受け取ったブロック内のBlobコミットメントを検証し、対応するBlobが正しく提供される前提で取引を一時保存します。またEngine APIもV3へ拡張され、ビーコンノードからBlobサイドカー情報を受け取って検証する手順が追加されています。これらの仕様変更により、Rethは新しいBlobトランザクションを他のノードと問題なくやり取りし、将来的なシャーディングへの布石となる機能を統合しました。"
    },
    {
      "change_type": "スナップシンク（Snap Sync）v2",
      "rationale": "初期同期時間を大幅に短縮するために考案されたスナップショット同期方式の改良版です。従来の高速同期（Fast Sync）やスナップ同期v1ではまだボトルネックとなっていた部分を改善し、より効率的に状態データを取得できるようにするためのプロトコル/実装アップデートです。",
      "impact_on_specification": "Rethは`snap`サブプロトコルを統合するアーキテクチャを採用しており、新たな改善にも対応できる設計でした。Snap Sync v2では、クライアント実装側で並列度をさらに高め、一度により大きな連続範囲の状態データを要求できるよう最適化されています（例えば多数のアカウントを連続したキー順に一括取得することで、ネットワーク往復回数を減らしています）。また、プロトコル上は依然としてRLP圧縮転送ですが、より賢いピア選択戦略により、負荷を分散しつつ帯域を最大限活用する改良がなされています。これらの変更により、Snap同期は従来よりも高速かつ安定して動作するようになり、Rethを含むクライアントは数時間程度でフルノード同期を完了できるよう仕様上サポートします。セキュリティ面でも、v2では各チャンクの検証と同時並行ダウンロードを組み合わせることで、不要データ送信によるジャンク攻撃を更に起こしにくくする効果があります。"
    }
  ]
}
