1. **疑念デフォルト原則**
   *「バグは必ず存在する」という前提でコードを読む。安全を仮定せず、矛盾点を探し続ける。*

2. **全体構造→局所検証の二段階パス**
   1️⃣ 仕様・資金フローを把握しながら粗く全体を俯瞰
   2️⃣ マークした高リスク部位を深掘りし、実際に exploitable か検証

3. **パターンマッチ思考**
   過去の有名バグ・エッジケース（reentrancy, rounding, unchecked‐call 等）のライブラリと常に照合。

4. **クリティカル面優先順位付け**

   * 資産を直接扱うロジック
   * 特権/Upgrade/Proxy 操作
   * クロスチェーン・複雑依存モジュール
   * 外部トークン受取・会計

5. **経済インパクト逆算**
   バグ発見後は「最悪シナリオ」を経済的視点で拡張し、利益化パスを設計して真の重大度を算出。

6. **仮説→PoC検証ループ**
   すべての潜在バグはテスト・fuzz・fork で再現して “実証”。コード上の懸念を確定バグへ昇格させる。

7. **ツールは思考増幅器**
   IDEナビゲーション・静的解析・fuzzer・Foundry 等を使い、手作業では困難な網羅性と試行回数を担保。

8. **異常値・境界値フェチ**
   0・1・MAX\_UINT・非18decimals 等、通常想定外の入力を積極投入して不変条件を破壊できるか確認。

9. **統合／繋ぎ込み懐疑**
   個別コントラクトが安全でも、組合せ（delegatecall・flash loan・batch）で破綻しないかを必ず検証。

10. **分析後レビュー & 失敗学**
    見逃したバグは「なぜ見逃したか」を自己/AIモデルにフィードバックし、検出ルールを更新して学習サイクルを回す。
