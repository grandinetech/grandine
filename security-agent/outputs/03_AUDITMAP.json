{
  "audit_items": [
    {
      "id": "FCC-DOS-001",
      "file": "fork_choice_control/src/controller.rs",
      "line": 240,
      "snippet": "self.spawn_block_task(block, BlockOrigin::Gossip(gossip_id))",
      "risk_category": "DoS",
      "description": "Unbounded task spawning for gossip blocks. Malicious peers could flood with invalid blocks to exhaust thread pool resources. Tasks added to unbounded VecDeque queues without limits.",
      "status": "Vuln",
      "review_round": 3,
      "proof_trace": [
        "Controller.on_gossip_block (L240)",
        "↳ Controller.spawn_block_task (L573)",
        "↳ Controller.spawn (L596)",
        "↳ ThreadPool.spawn (L70)",
        "↳ high_priority_tasks.push_back (L160)"
      ]
    },
    {
      "id": "FCC-DOS-002",
      "file": "fork_choice_control/src/controller.rs",
      "line": 375,
      "snippet": "AttestationVerifierMessage::Attestation { ... }.send(&self.attestation_verifier_tx)",
      "risk_category": "DoS",
      "description": "Unbounded attestation processing without rate limiting. Attackers can spam attestations to saturate attestation_verifier channel. No validation of subnet_id against expected subnets.",
      "status": "Vuln"
    },
    {
      "id": "FCC-DOS-003",
      "file": "fork_choice_control/src/controller.rs",
      "line": 361,
      "snippet": "AttestationVerifierMessage::AggregateAndProof { ... }.send(&self.attestation_verifier_tx)",
      "risk_category": "DoS",
      "description": "No rate limiting on aggregate attestations. Attackers can flood with invalid aggregates to exhaust attestation verifier channel. No validation of aggregator index or selection proof before queueing.",
      "status": "Vuln"
    },
    {
      "id": "FCC-DOS-004",
      "file": "fork_choice_control/src/controller.rs",
      "line": 476,
      "snippet": "self.spawn_blob_sidecar_task(blob_sidecar, block_seen, BlobSidecarOrigin::Gossip)",
      "risk_category": "DoS",
      "description": "Unbounded blob sidecar processing without rate limiting. Attackers can flood with invalid blobs to exhaust thread pool. KZG proof verification happens after task is already queued.",
      "status": "Vuln"
    },
    {
      "id": "FCC-EL-001",
      "file": "fork_choice_control/src/controller.rs",
      "line": 303,
      "snippet": "on_notified_new_payload(..., payload_status: PayloadStatusV1)",
      "risk_category": "ExecutionLayerTrust",
      "description": "EL validation verified in mutator. handle_notified_new_payload validates consistency between latest_valid_hash and execution_block_hash. Invalid payloads trigger proper invalidation.",
      "status": "ok",
      "review_round": 3
    },
    {
      "id": "FCC-WS-001",
      "file": "fork_choice_control/src/checkpoint_sync.rs",
      "line": 26,
      "snippet": "load_finalized_from_remote(...)",
      "risk_category": "WeakSubjectivity",
      "description": "No cryptographic verification of checkpoint authenticity. Trusts remote endpoint completely enabling long-range attacks if compromised. Should verify against hardcoded weak subjectivity checkpoints.",
      "status": "Vuln"
    },
    {
      "id": "FCC-STOR-001",
      "file": "fork_choice_control/src/storage.rs",
      "line": 106,
      "snippet": "pub async fn load(...)",
      "risk_category": "Storage",
      "description": "No integrity checks on loaded state data. Corrupted database could load invalid state as trusted anchor. Missing state root verification against known checkpoints.",
      "status": "Vuln"
    },
    {
      "id": "FCC-DA-001",
      "file": "fork_choice_control/src/mutator.rs",
      "line": 1180,
      "snippet": "if origin.is_from_el() { self.send_to_p2p(P2pMessage::PublishBlobSidecar(...)) }",
      "risk_category": "DataAvailability",
      "description": "EL blobs trusted by design. Execution layer is a trusted component that has already validated blobs. P2P propagation of EL-validated blobs is expected behavior.",
      "status": "ok",
      "review_round": 3
    },
    {
      "id": "FCC-DOS-005",
      "file": "fork_choice_control/src/thread_pool.rs",
      "line": 70,
      "snippet": "task.spawn(&mut self.shared.critical.lock())",
      "risk_category": "DoS",
      "description": "Unbounded task queues allow memory exhaustion. high_priority_tasks and low_priority_tasks are VecDeque without size limits. Attackers can flood to exhaust memory.",
      "status": "Vuln"
    },
    {
      "id": "FCC-DOS-006",
      "file": "fork_choice_control/src/mutator.rs",
      "line": 2043,
      "snippet": "self.delayed_until_blobs.insert(beacon_block_root, pending_block)",
      "risk_category": "DoS",
      "description": "Unbounded delayed_until_blobs HashMap with no size limits. Attackers can send blocks requiring blobs to exhaust memory. Each delayed block consumes memory until blobs arrive or pruning.",
      "status": "Vuln"
    },
    {
      "id": "FCC-DOS-007",
      "file": "fork_choice_control/src/mutator.rs",
      "line": 2120,
      "snippet": "self.delayed_until_block...attestations.push(pending_attestation)",
      "risk_category": "DoS",
      "description": "Unbounded Vec<PendingAttestation> per block in delayed_until_block. Attackers can spam attestations for future blocks to exhaust memory. No per-block limit on delayed attestations.",
      "status": "Vuln"
    },
    {
      "id": "FCC-DOS-008",
      "file": "fork_choice_control/src/mutator.rs",
      "line": 2207,
      "snippet": "self.delayed_until_slot...attestations.push(pending_attestation)",
      "risk_category": "DoS",
      "description": "Unbounded attestations per slot in BTreeMap. Can accumulate unlimited attestations for future slots. No validation of maximum future slot distance.",
      "status": "Vuln"
    },
    {
      "id": "FCC-OK-001",
      "file": "fork_choice_control/src/block_processor.rs",
      "line": 170,
      "snippet": "validate_block_for_gossip",
      "risk_category": "Validation",
      "description": "Proper validation through store.validate_block_for_gossip. State cache is used for performance with parent state as fallback.",
      "status": "ok"
    },
    {
      "id": "FCC-OK-002",
      "file": "fork_choice_control/src/state_at_slot_cache.rs",
      "line": 65,
      "snippet": "get_or_try_init",
      "risk_category": "CacheSecurity",
      "description": "Cache poisoning prevented by mutex locking and single initialization pattern.",
      "status": "ok"
    },
    {
      "id": "FCC-OK-003",
      "file": "fork_choice_control/src/storage.rs",
      "line": 101,
      "snippet": "load(...) prioritization logic",
      "risk_category": "TrustModel",
      "description": "Prioritizes local state over remote to prevent unnecessary network trust.",
      "status": "ok"
    }
  ],
  "summary": {
    "rounds": 3,
    "total_audit_flags": 10,
    "confirmed_vulnerabilities": 10,
    "false_positives": 2,
    "high_risk_hotspots": [
      "fork_choice_control/src/controller.rs:on_gossip_* functions (DoS)",
      "fork_choice_control/src/thread_pool.rs:spawn (Memory Exhaustion)",
      "fork_choice_control/src/mutator.rs:delayed_until_* collections (Unbounded Queues)",
      "fork_choice_control/src/checkpoint_sync.rs:load_finalized_from_remote (Weak Subjectivity)",
      "fork_choice_control/src/storage.rs:load (No Integrity Checks)"
    ],
    "next_focus": "Analyze attestation_verifier_tx channel capacity and implement rate limiting for gossip handlers"
  }
}